---
# Secret for Redfish credentials
apiVersion: v1
kind: Secret
metadata:
  name: redfish-credentials
  namespace: monitoring
type: Opaque
stringData:
  REDFISH_AUTH: "root:calvin"
---
# Redfish Hardware Monitor Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redfish-exporter
  template:
    metadata:
      labels:
        app: redfish-exporter
    spec:
      containers:
      - name: redfish-exporter
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
          - -c
          - |
            # Install required packages
            apt-get update && apt-get install -y curl
            
            # Create app directory
            mkdir -p /app
            
            # Create integrated Redfish exporter script
            cat > /app/redfish-hardware-exporter.py << 'EOF'
            #!/usr/bin/env python3
            import json
            import os
            import sys
            import time
            import ssl
            import base64
            from urllib import request, error
            from http.server import HTTPServer, BaseHTTPRequestHandler
            import signal

            # Node configuration
            NODES = {
                "console-node1": "10.10.1.21",
                "console-node2": "10.10.1.22", 
                "console-node3": "10.10.1.23",
                "console-node4": "10.10.1.24"
            }

            class RedfishHardwareCollector:
                def __init__(self):
                    self.last_collection_time = 0
                    self.cached_metrics = ""
                    self.collection_interval = 300  # seconds - longer interval to avoid restarts
                    self.auth_header = self._get_auth_header()
                    
                def _get_auth_header(self):
                    """Get Basic Auth header from environment"""
                    auth_string = os.environ.get('REDFISH_AUTH', 'root:calvin')
                    encoded_auth = base64.b64encode(auth_string.encode('utf-8')).decode('utf-8')
                    return f"Basic {encoded_auth}"
                    
                def collect_sensor_data(self, node_name, node_ip):
                    """Collect sensor data from a specific node"""
                    try:
                        url = f"https://{node_ip}/redfish/v1/Chassis/1/Thermal"
                        headers = {"Authorization": self.auth_header}
                        
                        req = request.Request(url, headers=headers, method="GET")
                        
                        # Ignore SSL certificate validation
                        ctx = ssl.create_default_context()
                        ctx.check_hostname = False
                        ctx.verify_mode = ssl.CERT_NONE
                        
                        with request.urlopen(req, context=ctx, timeout=60) as response:
                            response_body = response.read().decode('utf-8')
                            return json.loads(response_body)
                            
                    except Exception as e:
                        print(f"Error collecting data from {node_name} ({node_ip}): {e}", file=sys.stderr)
                        return None

                def format_prometheus_metrics(self, sensor_data, node):
                    """Convert sensor data to Prometheus format"""
                    metrics = []
                    
                    if not sensor_data:
                        return ""
                        
                    # Temperature metrics
                    if "Temperatures" in sensor_data:
                        for temp in sensor_data["Temperatures"]:
                            labels = {
                                'node': node,
                                'sensor_name': temp.get('Name', 'Unknown'),
                                'sensor_id': temp.get('MemberId', ''),
                                'physical_context': temp.get('PhysicalContext', 'Unknown').lower(),
                                'health_status': temp.get('Status', {}).get('Health', 'Unknown')
                            }
                            
                            # Temperature reading
                            if 'ReadingCelsius' in temp:
                                label_str = ','.join([f'{k}="{v}"' for k, v in labels.items()])
                                metrics.append(f'redfish_temperature_celsius{{{label_str}}} {temp["ReadingCelsius"]}')
                            
                            # Temperature thresholds
                            for threshold_type, metric_suffix in [
                                ('UpperThresholdCritical', 'upper_critical'),
                                ('UpperThresholdNonCritical', 'upper_warning'),
                                ('LowerThresholdCritical', 'lower_critical'),
                                ('LowerThresholdNonCritical', 'lower_warning')
                            ]:
                                if threshold_type in temp:
                                    threshold_labels = labels.copy()
                                    threshold_labels['threshold_type'] = metric_suffix
                                    threshold_label_str = ','.join([f'{k}="{v}"' for k, v in threshold_labels.items()])
                                    metrics.append(f'redfish_temperature_threshold_celsius{{{threshold_label_str}}} {temp[threshold_type]}')

                    # Fan metrics
                    if "Fans" in sensor_data:
                        for fan in sensor_data["Fans"]:
                            labels = {
                                'node': node,
                                'fan_name': fan.get('Name', 'Unknown'),
                                'fan_id': fan.get('MemberId', ''),
                                'health_status': fan.get('Status', {}).get('Health', 'Unknown')
                            }
                            
                            # Fan speed reading
                            if 'Reading' in fan:
                                label_str = ','.join([f'{k}="{v}"' for k, v in labels.items()])
                                metrics.append(f'redfish_fan_speed_rpm{{{label_str}}} {fan["Reading"]}')
                            
                            # Fan thresholds  
                            for threshold_type, metric_suffix in [
                                ('UpperThresholdCritical', 'upper_critical'),
                                ('UpperThresholdNonCritical', 'upper_warning'),
                                ('LowerThresholdCritical', 'lower_critical'),
                                ('LowerThresholdNonCritical', 'lower_warning')
                            ]:
                                if threshold_type in fan:
                                    threshold_labels = labels.copy()
                                    threshold_labels['threshold_type'] = metric_suffix
                                    threshold_label_str = ','.join([f'{k}="{v}"' for k, v in threshold_labels.items()])
                                    metrics.append(f'redfish_fan_threshold_rpm{{{threshold_label_str}}} {fan[threshold_type]}')

                    return '\n'.join(metrics)

                def collect_all_metrics(self):
                    """Collect metrics from all nodes"""
                    all_metrics = []
                    
                    # Add metadata
                    all_metrics.append('# HELP redfish_temperature_celsius Temperature reading in Celsius')
                    all_metrics.append('# TYPE redfish_temperature_celsius gauge')
                    all_metrics.append('# HELP redfish_temperature_threshold_celsius Temperature threshold values')
                    all_metrics.append('# TYPE redfish_temperature_threshold_celsius gauge')
                    all_metrics.append('# HELP redfish_fan_speed_rpm Fan speed in RPM')
                    all_metrics.append('# TYPE redfish_fan_speed_rpm gauge')
                    all_metrics.append('# HELP redfish_fan_threshold_rpm Fan speed threshold values')
                    all_metrics.append('# TYPE redfish_fan_threshold_rpm gauge')
                    all_metrics.append('# HELP redfish_collection_timestamp Timestamp of last collection')
                    all_metrics.append('# TYPE redfish_collection_timestamp gauge')
                    all_metrics.append('')

                    for node_name, node_ip in NODES.items():
                        print(f"Collecting metrics from {node_name} ({node_ip})...")
                        sensor_data = self.collect_sensor_data(node_name, node_ip)
                        
                        if sensor_data:
                            node_metrics = self.format_prometheus_metrics(sensor_data, node_name)
                            if node_metrics:
                                all_metrics.append(f'# Node: {node_name}')
                                all_metrics.append(node_metrics)
                                all_metrics.append('')
                                
                    # Add collection timestamp
                    all_metrics.append(f'redfish_collection_timestamp {int(time.time())}')
                    
                    return '\n'.join(all_metrics)

                def get_metrics(self):
                    """Get cached or fresh metrics based on collection interval"""
                    current_time = time.time()
                    
                    # Return cached metrics immediately if available
                    if self.cached_metrics:
                        # Only collect fresh if interval has passed
                        if current_time - self.last_collection_time > self.collection_interval:
                            print("Scheduling fresh hardware metrics collection...")
                            # Schedule collection in background (for now return cached)
                            # self.cached_metrics = self.collect_all_metrics()
                            # self.last_collection_time = current_time
                        return self.cached_metrics
                    
                    # If no cached metrics, return placeholder
                    return '''# HELP redfish_temperature_celsius Temperature reading in Celsius
# TYPE redfish_temperature_celsius gauge
# HELP redfish_collection_timestamp Timestamp of last collection
# TYPE redfish_collection_timestamp gauge
redfish_collection_timestamp 0'''


            class MetricsHandler(BaseHTTPRequestHandler):
                def __init__(self, collector, *args, **kwargs):
                    self.collector = collector
                    super().__init__(*args, **kwargs)
                
                def do_GET(self):
                    if self.path == '/metrics':
                        metrics = self.collector.get_metrics()
                        
                        self.send_response(200)
                        self.send_header('Content-Type', 'text/plain; charset=utf-8')
                        self.end_headers()
                        self.wfile.write(metrics.encode('utf-8'))
                    elif self.path == '/health' or self.path == '/':
                        self.send_response(200)
                        self.send_header('Content-Type', 'text/plain')
                        self.end_headers()
                        self.wfile.write(b'Redfish Hardware Exporter is running')
                    else:
                        self.send_response(404)
                        self.end_headers()
                
                def log_message(self, format, *args):
                    # Suppress default HTTP log messages
                    pass


            def create_handler(collector):
                def handler(*args, **kwargs):
                    return MetricsHandler(collector, *args, **kwargs)
                return handler


            def main():
                port = 9101
                
                # Create collector
                collector = RedfishHardwareCollector()
                
                # Create HTTP server
                handler = create_handler(collector)
                server = HTTPServer(('0.0.0.0', port), handler)
                
                print(f"Starting Redfish Hardware Exporter on port {port}")
                print(f"Monitoring nodes: {', '.join(NODES.keys())}")
                print(f"Collection interval: {collector.collection_interval} seconds")
                print(f"Metrics endpoint: http://localhost:{port}/metrics")
                
                def signal_handler(signum, frame):
                    print("\nShutting down exporter...")
                    server.shutdown()
                    sys.exit(0)
                
                signal.signal(signal.SIGINT, signal_handler)
                signal.signal(signal.SIGTERM, signal_handler)
                
                try:
                    server.serve_forever()
                except KeyboardInterrupt:
                    print("\nShutting down exporter...")
                    server.shutdown()

            if __name__ == '__main__':
                main()
            EOF
            
            chmod +x /app/redfish-hardware-exporter.py
            
            # Start the exporter
            cd /app
            exec python3 redfish-hardware-exporter.py
        ports:
        - containerPort: 9101
          name: metrics
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: REDFISH_AUTH
          valueFrom:
            secretKeyRef:
              name: redfish-credentials
              key: REDFISH_AUTH
        livenessProbe:
          httpGet:
            path: /health
            port: 9101
          initialDelaySeconds: 60
          periodSeconds: 60
          timeoutSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 9101
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 10
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
---
# Service for Redfish Exporter
apiVersion: v1
kind: Service
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
spec:
  selector:
    app: redfish-exporter
  ports:
  - name: metrics
    port: 9101
    targetPort: 9101
    protocol: TCP
  type: ClusterIP
---
# ServiceMonitor for Prometheus discovery
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
    release: kube-prometheus-stack
spec:
  selector:
    matchLabels:
      app: redfish-exporter
  endpoints:
  - port: metrics
    interval: 60s
    path: /metrics