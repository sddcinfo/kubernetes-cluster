---
# Redfish Hardware Monitoring Exporter
apiVersion: v1
kind: ConfigMap
metadata:
  name: redfish-exporter-scripts
  namespace: monitoring
data:
  redfish.py: |
    #!/usr/bin/env python3
    import argparse
    import json
    import os
    import ssl
    import sys
    from urllib import request, error
    import base64

    # --- Configuration ---
    NODES_FILE = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'nodes.json')
    CREDENTIALS_FILE = os.path.expanduser("~/.redfish_credentials")

    def get_node_ip(node_name):
        """Finds the IP address for a given node hostname."""
        try:
            with open(NODES_FILE) as f:
                nodes = json.load(f).get("nodes", [])
            for node in nodes:
                if node.get("hostname") == node_name:
                    return node.get("console_ip")
        except FileNotFoundError:
            print(f"Error: Nodes file not found at {NODES_FILE}", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError:
            print(f"Error: Could not decode JSON from {NODES_FILE}", file=sys.stderr)
            sys.exit(1)
        return None

    def get_redfish_credentials():
        """Reads and decodes the Basic Auth string from the credentials file."""
        try:
            with open(CREDENTIALS_FILE, 'r') as f:
                content = f.read().strip()
            if content.startswith('REDFISH_AUTH="') and content.endswith('"'):
                user_pass = content.split('"')[1]
                return base64.b64encode(user_pass.encode('utf-8')).decode('utf-8')
        except FileNotFoundError:
            print(f"Error: Credentials file not found at {CREDENTIALS_FILE}", file=sys.stderr)
            sys.exit(1)
        
        print(f"Error: Could not parse REDFISH_AUTH in {CREDENTIALS_FILE}", file=sys.stderr)
        sys.exit(1)

    def format_output(data, as_json=False, name_filter=None):
        """Formats the output as either human-readable or JSON."""
        # If a filter is applied to sensor data, process it first.
        if name_filter and ('Temperatures' in data or 'Fans' in data):
            filtered_data = {}
            name_filter_lower = name_filter.lower()
            
            temps = [t for t in data.get('Temperatures', []) if name_filter_lower in t.get('Name', '').lower()]
            if temps:
                filtered_data['Temperatures'] = temps
                
            fans = [f for f in data.get('Fans', []) if name_filter_lower in f.get('FanName', '').lower()]
            if fans:
                filtered_data['Fans'] = fans
            
            data = filtered_data # Replace original data with filtered data

        if as_json:
            return json.dumps(data, indent=4)
        
        if not data:
            return "No matching sensors found."

        # Simple human-readable format for success messages
        if "Success" in data:
            return f"Success: {data['Success']['Message']}"

        # Format for get-boot-options
        if "Boot" in data and isinstance(data["Boot"], dict):
            boot_info = data["Boot"]
            output = ["Boot Options:"]
            output.append(f"  - Boot Source Override Enabled: {boot_info.get('BootSourceOverrideEnabled')}")
            output.append(f"  - Boot Source Override Target: {boot_info.get('BootSourceOverrideTarget')}")
            output.append(f"  - Persistent Boot Order:")
            for i, device in enumerate(boot_info.get('BootOrder', [])):
                output.append(f"    {i+1}. {device}")
            return "\n".join(output)
        
        # Simple human-readable format for sensor data
        if "Temperatures" in data or "Fans" in data:
            output = ["Sensor Status:"]
            for temp in data.get('Temperatures', []):
                output.append(f"  - Temp: {temp.get('Name', 'N/A')}: {temp.get('ReadingCelsius', 'N/A')} C (Status: {temp.get('Status', {}).get('Health', 'N/A')})")
            for fan in data.get('Fans', []):
                output.append(f"  - Fan: {fan.get('FanName', 'N/A')}: {fan.get('Reading', 'N/A')} {fan.get('ReadingUnits', '')} (Status: {fan.get('Status', {}).get('Health', 'N/A')})")
            return "\n".join(output)
            
        # Default to pretty-printed JSON for other cases
        return json.dumps(data, indent=4)

    def main():
        """Main function to execute a simple Redfish command."""
        parser = argparse.ArgumentParser(description="A simplified script to send Redfish commands.")
        parser.add_argument("node", help="The hostname of the node (e.g., console-node2).")
        
        subparsers = parser.add_subparsers(dest="action", required=True, metavar='action')

        # Sensor parser
        parser_sensors = subparsers.add_parser("sensors", help="Get sensor data.")
        parser_sensors.add_argument("--filter", help="Filter sensors by name (case-insensitive substring).")
        parser_sensors.add_argument("--json", action="store_true", help="Output the result in JSON format.")
        
        # Boot parsers
        parser_get_boot = subparsers.add_parser("get-boot-options", help="Get boot options.")
        parser_get_boot.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        parser_set_boot = subparsers.add_parser("set-boot-next", help="Set the boot device for the next boot.")
        parser_set_boot.add_argument("device", help="The boot device to use (e.g., Pxe, Hdd, UefiShell). Use 'get-boot-options' to see available devices.")
        parser_set_boot.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        parser_get = subparsers.add_parser("get", help="Perform a GET request on an arbitrary Redfish path.")
        parser_get.add_argument("path", help="The Redfish API path to get (e.g., /redfish/v1/Systems/1).")
        parser_get.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        # Other actions
        parser_boot = subparsers.add_parser("set-boot-to-bios", help="Set the server to boot into BIOS setup on next restart.")
        parser_boot.add_argument("--json", action="store_true", help="Output the result in JSON format.")
        
        parser_power_on = subparsers.add_parser("power-on", help="Power on the server.")
        parser_power_on.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        parser_power_off = subparsers.add_parser("power-off", help="Gracefully shut down the server.")
        parser_power_off.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        parser_power_reboot = subparsers.add_parser("power-reboot", help="Gracefully restart the server.")
        parser_power_reboot.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        parser_power_cycle = subparsers.add_parser("power-cycle", help="Force restart the server.")
        parser_power_cycle.add_argument("--json", action="store_true", help="Output the result in JSON format.")

        args = parser.parse_args()

        node_ip = get_node_ip(args.node)
        if not node_ip:
            print(f"Error: IP address for node '{args.node}' not found.", file=sys.stderr)
            sys.exit(1)

        # Define API actions
        actions = {
            "sensors": {
                "path": "/redfish/v1/Chassis/1/Thermal",
                "method": "GET",
                "payload": None
            },
            "get-boot-options": {
                "path": "/redfish/v1/Systems/1",
                "method": "GET",
                "payload": None
            },
            "set-boot-next": {
                "path": "/redfish/v1/Systems/1",
                "method": "PATCH",
                "payload": {"Boot": {"BootSourceOverrideEnabled": "Once", "BootSourceOverrideTarget": args.device if args.action == "set-boot-next" else None}}
            },
            "get": {
                "path": args.path if args.action == "get" else None,
                "method": "GET",
                "payload": None
            },
            "set-boot-to-bios": {
                "path": "/redfish/v1/Systems/1",
                "method": "PATCH",
                "payload": {"Boot": {"BootSourceOverrideEnabled": "Once", "BootSourceOverrideTarget": "BiosSetup"}}
            },
            "power-on": {
                "path": "/redfish/v1/Systems/1/Actions/ComputerSystem.Reset",
                "method": "POST",
                "payload": {"ResetType": "On"}
            },
            "power-off": {
                "path": "/redfish/v1/Systems/1/Actions/ComputerSystem.Reset",
                "method": "POST",
                "payload": {"ResetType": "GracefulShutdown"}
            },
            "power-reboot": {
                "path": "/redfish/v1/Systems/1/Actions/ComputerSystem.Reset",
                "method": "POST",
                "payload": {"ResetType": "GracefulRestart"}
            },
            "power-cycle": {
                "path": "/redfish/v1/Systems/1/Actions/ComputerSystem.Reset",
                "method": "POST",
                "payload": {"ResetType": "ForceRestart"}
            }
        }
        
        action_details = actions[args.action]
        url = f"https://{node_ip}{action_details['path']}"
        auth_header = f"Basic {get_redfish_credentials()}"
        
        headers = {"Authorization": auth_header}
        payload = None
        if action_details['payload']:
            headers['Content-Type'] = 'application/json'
            payload = json.dumps(action_details['payload']).encode('utf-8')

        req = request.Request(url, headers=headers, method=action_details['method'], data=payload)
        
        # Ignore SSL certificate validation
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        try:
            with request.urlopen(req, context=ctx) as response:
                response_body = response.read().decode('utf-8')
                data = json.loads(response_body) if response_body else {"Success": {"Message": f"Action '{args.action}' completed with status {response.getcode()}."}}
                
                name_filter = getattr(args, 'filter', None)
                print(format_output(data, args.json, name_filter))

        except error.HTTPError as e:
            print(f"Error: HTTP request failed for node '{args.node}' with status {e.code}.", file=sys.stderr)
            try:
                body = e.read().decode('utf-8')
                print(f"Response body:\n{body}", file=sys.stderr)
            except Exception:
                pass # Ignore if reading body fails
            sys.exit(1)
        except Exception as e:
            print(f"An unexpected error occurred for node '{args.node}': {e}", file=sys.stderr)
            sys.exit(1)

    if __name__ == "__main__":
        main()
  nodes.json: |
    {
      "nodes": [
        {
          "hostname": "console-node1",
          "console_ip": "10.10.1.11"
        },
        {
          "hostname": "console-node2", 
          "console_ip": "10.10.1.12"
        },
        {
          "hostname": "console-node3",
          "console_ip": "10.10.1.13"
        },
        {
          "hostname": "console-node4",
          "console_ip": "10.10.1.14"
        }
      ]
    }
  redfish-prometheus-exporter.py: |
    #!/usr/bin/env python3
    """
    Redfish Prometheus Exporter for Hardware Sensor Monitoring
    Collects temperature and fan data from multiple Redfish-enabled nodes
    """

    import json
    import os
    import sys
    import time
    import subprocess
    import argparse
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from urllib.parse import urlparse, parse_qs
    import threading
    import signal


    class RedfishCollector:
        def __init__(self, redfish_script_path, nodes=None):
            self.redfish_script = redfish_script_path
            self.nodes = nodes or ["console-node1", "console-node2", "console-node3", "console-node4"]
            self.last_collection_time = 0
            self.cached_metrics = ""
            self.collection_interval = 30  # seconds
            
        def collect_sensor_data(self, node):
            """Collect sensor data from a specific node"""
            try:
                cmd = [sys.executable, self.redfish_script, node, "sensors", "--json"]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    return json.loads(result.stdout)
                else:
                    print(f"Error collecting data from {node}: {result.stderr}", file=sys.stderr)
                    return None
                    
            except subprocess.TimeoutExpired:
                print(f"Timeout collecting data from {node}", file=sys.stderr)
                return None
            except json.JSONDecodeError as e:
                print(f"JSON decode error for {node}: {e}", file=sys.stderr)
                return None
            except Exception as e:
                print(f"Unexpected error collecting data from {node}: {e}", file=sys.stderr)
                return None

        def format_prometheus_metrics(self, sensor_data, node):
            """Convert sensor data to Prometheus format"""
            metrics = []
            
            if not sensor_data:
                return ""
                
            # Temperature metrics
            if "Temperatures" in sensor_data:
                for temp in sensor_data["Temperatures"]:
                    labels = {
                        'node': node,
                        'sensor_name': temp.get('Name', 'Unknown'),
                        'sensor_id': temp.get('MemberId', ''),
                        'physical_context': temp.get('PhysicalContext', 'Unknown').lower(),
                        'health_status': temp.get('Status', {}).get('Health', 'Unknown')
                    }
                    
                    # Temperature reading
                    if 'ReadingCelsius' in temp:
                        label_str = ','.join([f'{k}="{v}"' for k, v in labels.items()])
                        metrics.append(f'redfish_temperature_celsius{{{label_str}}} {temp["ReadingCelsius"]}')
                    
                    # Temperature thresholds
                    for threshold_type, metric_suffix in [
                        ('UpperThresholdCritical', 'upper_critical'),
                        ('UpperThresholdNonCritical', 'upper_warning'),
                        ('LowerThresholdCritical', 'lower_critical'),
                        ('LowerThresholdNonCritical', 'lower_warning')
                    ]:
                        if threshold_type in temp:
                            threshold_labels = labels.copy()
                            threshold_labels['threshold_type'] = metric_suffix
                            threshold_label_str = ','.join([f'{k}="{v}"' for k, v in threshold_labels.items()])
                            metrics.append(f'redfish_temperature_threshold_celsius{{{threshold_label_str}}} {temp[threshold_type]}')

            # Fan metrics
            if "Fans" in sensor_data:
                for fan in sensor_data["Fans"]:
                    labels = {
                        'node': node,
                        'fan_name': fan.get('Name', 'Unknown'),
                        'fan_id': fan.get('MemberId', ''),
                        'health_status': fan.get('Status', {}).get('Health', 'Unknown')
                    }
                    
                    # Fan speed reading
                    if 'Reading' in fan:
                        label_str = ','.join([f'{k}="{v}"' for k, v in labels.items()])
                        metrics.append(f'redfish_fan_speed_rpm{{{label_str}}} {fan["Reading"]}')
                    
                    # Fan thresholds
                    for threshold_type, metric_suffix in [
                        ('UpperThresholdCritical', 'upper_critical'),
                        ('UpperThresholdNonCritical', 'upper_warning'),
                        ('LowerThresholdCritical', 'lower_critical'),
                        ('LowerThresholdNonCritical', 'lower_warning')
                    ]:
                        if threshold_type in fan:
                            threshold_labels = labels.copy()
                            threshold_labels['threshold_type'] = metric_suffix
                            threshold_label_str = ','.join([f'{k}="{v}"' for k, v in threshold_labels.items()])
                            metrics.append(f'redfish_fan_threshold_rpm{{{threshold_label_str}}} {fan[threshold_type]}')

            return '\n'.join(metrics)

        def collect_all_metrics(self):
            """Collect metrics from all nodes"""
            all_metrics = []
            
            # Add metadata
            all_metrics.append('# HELP redfish_temperature_celsius Temperature reading in Celsius')
            all_metrics.append('# TYPE redfish_temperature_celsius gauge')
            all_metrics.append('# HELP redfish_temperature_threshold_celsius Temperature threshold values')
            all_metrics.append('# TYPE redfish_temperature_threshold_celsius gauge')
            all_metrics.append('# HELP redfish_fan_speed_rpm Fan speed in RPM')
            all_metrics.append('# TYPE redfish_fan_speed_rpm gauge')
            all_metrics.append('# HELP redfish_fan_threshold_rpm Fan speed threshold values')
            all_metrics.append('# TYPE redfish_fan_threshold_rpm gauge')
            all_metrics.append('')

            for node in self.nodes:
                print(f"Collecting metrics from {node}...")
                sensor_data = self.collect_sensor_data(node)
                
                if sensor_data:
                    node_metrics = self.format_prometheus_metrics(sensor_data, node)
                    if node_metrics:
                        all_metrics.append(f'# Node: {node}')
                        all_metrics.append(node_metrics)
                        all_metrics.append('')
                        
            # Add collection timestamp
            all_metrics.append(f'redfish_collection_timestamp {int(time.time())}')
            
            return '\n'.join(all_metrics)

        def get_metrics(self):
            """Get cached or fresh metrics based on collection interval"""
            current_time = time.time()
            
            if current_time - self.last_collection_time > self.collection_interval:
                print("Collecting fresh metrics...")
                self.cached_metrics = self.collect_all_metrics()
                self.last_collection_time = current_time
                
            return self.cached_metrics


    class MetricsHandler(BaseHTTPRequestHandler):
        def __init__(self, collector, *args, **kwargs):
            self.collector = collector
            super().__init__(*args, **kwargs)
        
        def do_GET(self):
            if self.path == '/metrics':
                metrics = self.collector.get_metrics()
                
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain; charset=utf-8')
                self.end_headers()
                self.wfile.write(metrics.encode('utf-8'))
            elif self.path == '/health' or self.path == '/':
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.end_headers()
                self.wfile.write(b'Redfish Exporter is running')
            else:
                self.send_response(404)
                self.end_headers()
        
        def log_message(self, format, *args):
            # Suppress default HTTP log messages
            pass


    def create_handler(collector):
        def handler(*args, **kwargs):
            return MetricsHandler(collector, *args, **kwargs)
        return handler


    def main():
        parser = argparse.ArgumentParser(description='Redfish Prometheus Exporter')
        parser.add_argument('--port', type=int, default=9101, help='Port to listen on (default: 9101)')
        parser.add_argument('--redfish-script', default='/app/scripts/redfish.py',
                           help='Path to redfish.py script')
        parser.add_argument('--nodes', nargs='+', 
                           default=['console-node1', 'console-node2', 'console-node3', 'console-node4'],
                           help='List of nodes to monitor')
        parser.add_argument('--interval', type=int, default=30, help='Collection interval in seconds (default: 30)')
        
        args = parser.parse_args()
        
        # Validate redfish script exists
        if not os.path.exists(args.redfish_script):
            print(f"Error: Redfish script not found at {args.redfish_script}")
            sys.exit(1)
        
        # Create collector
        collector = RedfishCollector(args.redfish_script, args.nodes)
        collector.collection_interval = args.interval
        
        # Create HTTP server
        handler = create_handler(collector)
        server = HTTPServer(('0.0.0.0', args.port), handler)
        
        print(f"Starting Redfish Prometheus Exporter on port {args.port}")
        print(f"Monitoring nodes: {', '.join(args.nodes)}")
        print(f"Collection interval: {args.interval} seconds")
        print(f"Metrics endpoint: http://localhost:{args.port}/metrics")
        
        def signal_handler(signum, frame):
            print("\nShutting down exporter...")
            server.shutdown()
            sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            print("\nShutting down exporter...")
            server.shutdown()


    if __name__ == '__main__':
        main()
---
# Secret for Redfish credentials
apiVersion: v1
kind: Secret
metadata:
  name: redfish-credentials
  namespace: monitoring
type: Opaque
stringData:
  redfish_credentials: 'REDFISH_AUTH="root:calvin"'
---
# Redfish Hardware Monitor Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redfish-exporter
  template:
    metadata:
      labels:
        app: redfish-exporter
    spec:
      containers:
      - name: redfish-exporter
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
          - -c
          - |
            # Install required packages
            apt-get update && apt-get install -y curl
            
            # Create app directories
            mkdir -p /app/scripts
            
            # Copy scripts to container
            cp /config/redfish.py /app/scripts/redfish.py
            cp /config/nodes.json /app/scripts/nodes.json
            cp /config/redfish-prometheus-exporter.py /app/redfish-prometheus-exporter.py
            chmod +x /app/scripts/redfish.py /app/redfish-prometheus-exporter.py
            
            # Set up credentials file
            mkdir -p /root
            cp /secrets/redfish_credentials /root/.redfish_credentials
            
            # Start the exporter
            cd /app
            exec python3 redfish-prometheus-exporter.py --port 9101 --interval 60
        ports:
        - containerPort: 9101
          name: metrics
        volumeMounts:
        - name: scripts-config
          mountPath: /config
        - name: redfish-credentials
          mountPath: /secrets
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        livenessProbe:
          httpGet:
            path: /health
            port: 9101
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 9101
          initialDelaySeconds: 10
          periodSeconds: 10
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
      volumes:
      - name: scripts-config
        configMap:
          name: redfish-exporter-scripts
          defaultMode: 0755
      - name: redfish-credentials
        secret:
          secretName: redfish-credentials
          defaultMode: 0600
---
# Service for Redfish Exporter
apiVersion: v1
kind: Service
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
spec:
  selector:
    app: redfish-exporter
  ports:
  - name: metrics
    port: 9101
    targetPort: 9101
    protocol: TCP
  type: ClusterIP
---
# ServiceMonitor for Prometheus discovery
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: redfish-exporter
  namespace: monitoring
  labels:
    app: redfish-exporter
    release: kube-prometheus-stack
spec:
  selector:
    matchLabels:
      app: redfish-exporter
  endpoints:
  - port: metrics
    interval: 60s
    path: /metrics